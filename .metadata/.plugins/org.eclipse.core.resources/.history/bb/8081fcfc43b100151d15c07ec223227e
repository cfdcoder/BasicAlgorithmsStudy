package study;
/**
 * this is the simple implementation of binary search tree: 
 * in-order traverse, post-order traverse, pre-order traverse
 * add node
 * delete node
 * */
public class BinarySearchTree {
    Node root;
    
    //create a new node and initialize it
    public void addNewNode(int key, String data){
    	Node newNode=new Node(key, data);
    	if(root==null){//if empty tree, set the new node as the root node
    		root=newNode;
    	}else{
    		//set root node as the start point
    		Node focusNode=root;
    		//set the parent node for the new node
    		Node parent;
    		while(true){
    			parent=focusNode;//set the parent node to the root node as start point
    			//check if the new node should go to the left
    			if(key<focusNode.key){
    				//switch focus to the left child
    				focusNode=focusNode.leftChild;
    				if(focusNode==null){//no left child there
    					parent.leftChild=newNode;// add newnode tobe the leftchild of the parent
    					return;//all done
    				}
    			}else{//check if the new node should go to the right
    				focusNode=focusNode.rightChild;
    				if(focusNode==null){//no right child there
    					parent.rightChild=newNode;// add newnode tobe the rightchild of the parent
    					return;
    				}
    			}
    		}
    	}
    }
    
    //inorder traverse order: leftchild, parent, rightchild
    public void inOrderTraverse(Node focusNode){
    	if(focusNode!=null){
    		inOrderTraverse(focusNode.leftChild);
    		System.out.println(focusNode);
    		inOrderTraverse(focusNode.rightChild);
    	}
    }
    
    //preorder traverse order: parent, leftchild, rightchild
    public void preOrderTraverse(Node focusNode){
    	if(focusNode!=null){
    		System.out.println(focusNode);
    		preOrderTraverse(focusNode.leftChild);
    		preOrderTraverse(focusNode.rightChild);
    	}
    }
    
    //postorder traverse order:  leftchild, rightchild, parent,
    public void postOrderTraverse(Node focusNode){
    	if(focusNode!=null){
    		
    		postOrderTraverse(focusNode.leftChild);
    		postOrderTraverse(focusNode.rightChild);
    		System.out.println(focusNode);
    	}
    }
    
    //find a node
    public Node findNode(int key){
    	//start with the root of the tree
    	Node focusNode=root;
    	while(focusNode.key!=key){
    		if(key<focusNode.key){
    			//we needto search on the left child
    			focusNode=focusNode.leftChild;
    		}else{
    			//we needto search on the right child
    			focusNode=focusNode.rightChild;
    		}
    		//if the node was not found
    		if(focusNode==null) return null;
    	}
    	return focusNode;
    }
    
    //delete a node   
    public boolean removeNode(int key){
    	//start at the root node
    	Node focusNode=root;
    	Node parent =root;
    	//set up a flag to tell us where to search: left
    	boolean isItLeftChild=true;
    	
    	//check if the tree is empty, if it is return it as false
    	if (root == null)
    	    return false;
    	
    	
    	while(focusNode.key!=key){
    		parent=focusNode;
    		// if smaller than the parent node, we need to go to the left
    		if(key<focusNode.key){
    			isItLeftChild=true;
    			focusNode=focusNode.leftChild;
    		}else{
    			// if bigger than the parent node, we need to go to the right
    			isItLeftChild=false;
    			focusNode=focusNode.rightChild;
    		}
    		
    		if(focusNode==null) return false;
    	}//end while
    	
    	//specia case 1: if the parent node has no left child and no right child
    	if(focusNode.leftChild==null && focusNode.rightChild==null){
    		//if root only, delete the root
    		if(focusNode==root) root=null;
    		//if it was marked as a left child, delete it
    		else if(isItLeftChild) parent.leftChild=null;
    		//otherwise, delete the right child
    		else parent.rightChild=null;
    	}
    	
    	//special case2: if the parent node has no right child
    	else if(focusNode.rightChild==null){
    		if(focusNode==root)  root=focusNode.leftChild;
    		else if(isItLeftChild) parent.leftChild=focusNode.leftChild;
    		else      parent.rightChild=focusNode.leftChild;
    	}
    	
    	//special case3: if the parent node has no left child
    	else if(focusNode.leftChild==null){
    		if(focusNode==root)  root=focusNode.rightChild;
    		else if(isItLeftChild) parent.leftChild=focusNode.rightChild;
    		else      parent.rightChild=focusNode.leftChild;
    	}
    	
    	//special case4: if the parent node has both left and right node, find the node to be replaced
    	else{
    		Node replacement =getReplacementNode(focusNode);
    		//if the focusenode is the root, relace it with the replacementNode;
    		if(focusNode==root)   			root=replacement;
    		//if the deleted node was a left child, replace the left child
    		else if(isItLeftChild)
    			parent.leftChild=replacement;
    		//otherwise, replace the right child
    		else
    			parent.rightChild=replacement;
    		
    		replacement.leftChild=focusNode.leftChild;
    	}
    	
    	return true;

    }
    
    public Node getReplacementNode(Node replacedNode){
    	Node replacementParent=replacedNode;
    	Node replacement =replacedNode;
    	Node focusNode=replacedNode.rightChild;
    	while(focusNode!=null){
    		replacementParent=replacement;
    		replacement=focusNode;
    		focusNode=focusNode.leftChild;
    	}
    	if(replacement!=replacedNode.rightChild){
    		replacementParent.leftChild=replacement.rightChild;
    		replacement.rightChild=replacedNode.rightChild;
    	}
    	return replacement;
    }
    
	public static void main(String[] args) {
		// TODO Auto-generated method stub
        BinarySearchTree tree=new BinarySearchTree();
        
        //add new node
        tree.addNewNode(1, "Boss");
        tree.addNewNode(2, "President");
        tree.addNewNode(3, "Head");
        tree.addNewNode(4, "Manager");
        tree.addNewNode(5, "Secretary");
        tree.addNewNode(6, "Salesman");
        
        //check traverse implementation
        //tree.inOrderTraverse(tree.root);
        //tree.preOrderTraverse(tree.root);
        System.out.println("tree data before deleted key:");
        tree.postOrderTraverse(tree.root);
        
        //System.out.println("search data with key 3");
        //System.out.println(tree.findNode(3));
        System.out.println(" ");
        System.out.println("remove data with key 3");
        System.out.println(tree.removeNode(3));
        System.out.println("tree data after deleted key:");
        tree.inOrderTraverse(tree.root);
	}

}

//define the nodes in the binary search tree
class Node{
	int key;
	String data;
	
	Node leftChild;
	Node rightChild;
	
	Node(int key, String data){
		this.key=key;
		this.data=data;
	}
	
	public String toString(){
		return this.data+" has a key "+ this.key;
	}
}